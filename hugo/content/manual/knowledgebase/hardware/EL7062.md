+++  
title = "EL7062"   
weight = 22
chapter = false  
+++

## Topics
1. [error/warning](#error/warning)
2. [openloop counter jump](#openloop-counter-jump)
3. [tuning](#tuning)
4. [home on index pulse of incremental encoder](#home-on-index-pulse-of-incremental-encoder)

### error/warning
If the drive is in error/warning state and not possible to enable, see [drive refuse to enable](../../motion/#drive-refuse-to-enable).

The most common reason for this error is:
* motor is not connected
* (PSI specific): motor cable in wrong connector (at PSI motor and limits have the same 5pin M12 connector)
* drive has no motor voltage
* (PSI specific): EL9227-5500 feeding the I/O bus is not initiated (at first power on the switches on the terminal needs to be engaged)

### Openloop counter jump
The EL7062 has a firmware bug if configured to run in open loop CSV.

When disabling the amplifier the open loop counter jump to nearest full turn value.
Beckhoff works on a fix...

{{% notice info %}}
**Use CSP mode until CSV bug is fixed by Beckhoff**
{{% /notice %}}

### Tuning
{{% notice warning %}}
**Motor might move during tuning sequence**
{{% /notice %}}

If tuning is off an autotune sequence can be executed from the hardware expert panel. The auto tuning sequence measures coil resistance and inductance and sets initial values for control loop parameters:
* Coil resistance
* Coil inductance
* Current loop proportional gain
* Current loop integration time
* Velocity loop proportional gain
* Velocity loop integration time
* Position loop proportional gain  (used in CSP only)

The autotune process also creates an MACROS string that can be used with ecmccomp to set the parameters at startup.

Requirements for a sucessful tuning:
* Drive must be in OP mode
* Drive must _not_ be enabled
* Drive must have motor power

For more info see Beckhoff docs.

Sometimes further finetuning of the parameters might be needed.

{{% notice warning %}}
**Motor might move during tuning sequence**
{{% /notice %}}

### Home on index pulse of incremental encoder
The incremental inteface of the EL7062 works in a similar ways as the EL72XX servos and are different compared to the EL5101 interface. For EL7062 the latch functionality is called touchprobes. Each channel of the drive are equipped with two touch probes which can be configured to latch on an digital input or on the index pulse of the incremental encoder. The encoder source of the touchprobes can also be configured as openloop counter or incremental encoder (secondary encoder).

#### SDO configs:
##### Configure touch probe to latch on encoder index pulse

The following commands can be used (see beckhoff manula for more info):
```
# CH1 Set touch probe to latch on index pulse
ecmcConfigOrDie "Cfg.EcAddSdo(${ECMC_EC_SLAVE_NUM},0x8001,0x11,5,2)"

# CH2 Set touch probe to latch on index pulse
ecmcConfigOrDie "Cfg.EcAddSdo(${ECMC_EC_SLAVE_NUM},0x8101,0x11,5,2)"
```

##### Configure touch probe encoder source
```
# CH1 Set touch probe source 01 to secondary encoder
ecmcConfigOrDie "Cfg.EcAddSdo(${ECMC_EC_SLAVE_NUM},0x8001,0x15,1,2)"

# CH2 Set touch probe source 01 to secondary encoder
ecmcConfigOrDie "Cfg.EcAddSdo(${ECMC_EC_SLAVE_NUM},0x8101,0x15,1,2)"
```

##### Using ecmcomp
These commands are also accessible via the Encoder-Generic-INC component of ecmccomp:

The follwoing macros are implemented:
```
TP1_POS_SRC   : Touchprobe 1 source
                  PRIM: primary encoder (open loop counter)
                  SEC: secondary encoder (incremental encoder)
TP2_POS_SRC   : Touchprobe 2 source
                  PRIM: primary encoder (open loop counter)
                  SEC: secondary encoder (incremental encoder)
TP1_TRG       : Touchprobe 1 trigger
                  TPBI: touch probe input 1
                  INDEX: encoder index pulse
TP2_TRG       : Touchprobe 2 trigger
                  TPBI: touch probe input 2
                  INDEX: encoder index pulse
Example:
${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd "COMP=Encoder-Generic-INC,          CH_ID=2, MACROS='ST_ENC_RES=4000,TP1_POS_SRC=SEC,TP1_TRG=INDEX'"
```

#### Arm latch
Arming a latch/touchprobe is a bit more complex than when using EL5101 and its done by the touch probe control word (covering both touch probes):
| bit| tp ch|desc|
| ---| ---|---|
| 0  | 1  | enable touch probe|
| 1  | 1  | enable continous latching|
| 2  | 1  | trig mode B1|
| 3  | 1  | trig mode B2|
| 4  | 1  | latch on positive edge|
| 5  | 1  | latch on negative edge|
| 6  | 1  | reserved|
| 7  | 1  | reserved|
| 8  | 2  | enable touch probe|
| 9  | 2  | enable continous latching|
| 10 | 2  | trig mode B1|
| 11 | 2  | trig mode B2|
| 12 | 2  | latch on positive edge|
| 13 | 2  | latch on negative edge|
| 14 | 2  | reserved|
| 15 | 2  | reserved|

The ecmc parameter for accessing the control word is: 
* CH1: ec0.s$(ENC_SID).touchProbeControl01
* CH2: ec0.s$(ENC_SID).touchProbeControl02

As an example, arming the touchprobe for the following scenario:
* Drive channel 1
* Touch probe 1
* latching positive edge

would reuqire the follwoing bits in the ec0.s$(ENC_SID).touchProbeControl01 to be set:
* 0: enable
* 2: trig mode B1
* 4: latch on positive edge
or 0b10101 = 21dec

when setting up homing for an encoder in ecmccfg the latch/touchprobe then needs to be configured in the follwoing way:

```
encoder:
  desc: Inc RS422
  numerator: 360                                       # Scaling numerator example 1 mm/rev
  denominator: 1048576                                 # Scaling denominator example 4096 ticks per 360 degree
  type: 0                                              # Type: 0=Incremental, 1=Absolute
  bits: 32                                             # Total bit count of encoder raw data
  absBits: 0                                           # Absolute bit count (for absolute encoders) always least significant part of 'bits'
  position: ec0.s$(ENC_SID).positionActual${ENC_CH=01}_2 # Ethercat entry for actual position input (encoder)
  status: ec0.s$(ENC_SID).touchProbeStatus${ENC_CH=01}         # mandatory only if 'warning' or 'error' are used
  control: ec0.s$(ENC_SID).touchProbeControl${ENC_CH=01}
  primary: True
  latch:
    position: ec0.s$(ENC_SID).touchProbePositionPos$(ENC_CH=01)_1 # Link to latched value 1
    control:  0                                        # Bit in encoder control word to arm latch.
    status: 1                                          # Bit in encoder status word for latch triggered status.
    armCmd: 21                                         # Arm command, 0b10101 for EL7062 touch probes
    armBits: 5                                         # Arm command bit size, 5 bits for EL7062 touch probes
  homing:
    type: 12                                           # Homing sequence type
    position: 0                                        # Position to reference encoder to
    velocity:
      to: 30                                           # Velocity to cam/sensor (used for some homing seqs)
      from: 20                                          # Velocity from cam/sensor (used for some homing seqs)
    acceleration: 20                                   # Acceleration during homing
    deceleration: 100                                  # Deceleration during homing
    latchCount: 1                                      # latch number to ref on (1=ref on first latch)
```

here the follwoing controls the arming of the latch:
* encoder.control:  touchprobe control word.
* encoder.latch.control: start bit in touchprobe control word to write "encoder.latch.armBits" bits of arm command (encoder.latch.armCmd)
* encoder.latch.armCmd: Decimal value of bit pattern to arm touch probe
* encoder.latch.armBits: Bit length of encoder.latch.armCmd to write into encoder.control (starting at bit position encoder.latch.control)
and status/result:
* encoder.latch.status bit of encoder.status word toggles when a new touchprobe latches
* encoder.latch.position:  the latched position

#### Startup file example
```
require ecmccfg "ENG_MODE=1"

${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd,      "SLAVE_ID=3,HW_DESC=EL7062_CSP"
${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd "COMP=Motor-Generic-2Phase-Stepper, CH_ID=1, MACROS='I_MAX_MA=1000, I_STDBY_MA=100, U_NOM_MV=24000,L_COIL_UH=3050,R_COIL_MOHM=2630'"
${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd "COMP=Drive-Generic-Ctrl-Params,    CH_ID=1, MACROS='I_TI=12,I_KP=58,V_TI=150,V_KP=176,P_KP=10'"
# configure touch probe to latch on index pulse of secondary encoder (incremental)
${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd "COMP=Encoder-Generic-INC,          CH_ID=1, MACROS='ST_ENC_RES=4000,TP1_POS_SRC=SEC,TP1_TRG=INDEX'"
epicsEnvSet(DRV_SID,${ECMC_EC_SLAVE_NUM})

# Configure axis and open loop encoder
${SCRIPTEXEC} ${ecmccfg_DIR}loadYamlAxis.cmd,   "FILE=./cfg/axis.yaml,          DEV=${IOC}, AX_NAME=M1, AXIS_ID=1, DRV_SID=${DRV_SID}, ENC_SID=${DRV_SID}, ENC_CH=01" 

# Configure incremental encoder
${SCRIPTEXEC} ${ecmccfg_DIR}loadYamlEnc.cmd,    "FILE=./cfg/enc_inc.yaml, DEV=${IOC}, ENC_SID=${DRV_SID},ENC_CH=02"
```
